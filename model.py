# -*- coding: utf-8 -*-
"""model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1834MkDH8_eXhZ5h-teDyOHtR7PvT2oqi
"""

import torch
import torch.nn as nn
import torch.nn.functional as F
from torchvision import models

# GeM Pooling Layer (Generalized Mean Pooling)
class GeM(nn.Module):
    def __init__(self, p=3.0, eps=1e-6):
        super(GeM, self).__init__()
        self.p = nn.Parameter(torch.ones(1) * p)
        self.eps = eps

    def forward(self, x):
        return F.avg_pool2d(x.clamp(min=self.eps).pow(self.p), (x.size(-2), x.size(-1))).pow(1. / self.p)


# Simple Capsule Layer (Not dynamic routing for simplicity)
class CapsuleLayer(nn.Module):
    def __init__(self, num_capsules, in_channels, out_channels):
        super(CapsuleLayer, self).__init__()
        self.capsules = nn.ModuleList([
            nn.Conv2d(in_channels, out_channels, kernel_size=9, stride=2, padding=0)
            for _ in range(num_capsules)
        ])

    def forward(self, x):
        u = [caps(x).view(x.size(0), -1, 1) for caps in self.capsules]
        u = torch.cat(u, dim=-1)
        u_squash = self.squash(u)
        return u_squash

    def squash(self, inputs):
        norm = torch.norm(inputs, dim=1, keepdim=True)
        scale = (norm ** 2) / (1 + norm ** 2)
        return scale * inputs / (norm + 1e-8)

# Feature Extractor Model
class TeaLeafFeatureExtractor(nn.Module):
    def __init__(self):
        super(TeaLeafFeatureExtractor, self).__init__()
        self.conv1 = nn.Conv2d(3, 64, kernel_size=5, stride=1, padding=2)
        self.bn1 = nn.BatchNorm2d(64)
        self.conv2 = nn.Conv2d(64, 128, kernel_size=5, stride=1, padding=2)
        self.bn2 = nn.BatchNorm2d(128)

        self.capsule = CapsuleLayer(num_capsules=8, in_channels=128, out_channels=16)
        self.gem_pool = GeM()

    def forward(self, x):
        x = F.relu(self.bn1(self.conv1(x)))
        x = F.relu(self.bn2(self.conv2(x)))
        x = self.capsule(x)  # output shape: (batch, features, capsules)
        x = x.view(x.size(0), -1, x.size(-1))  # flatten spatially
        x = x.mean(dim=-1)  # reduce across capsules
        x = x.unsqueeze(-1).unsqueeze(-1)  # prepare for pooling
        x = self.gem_pool(x)
        return x.view(x.size(0), -1)  # final feature vector